//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using KSP;
using UnityEngine;
using ModularFI;

namespace DeadlyReentry
{
    [KSPAddon(KSPAddon.Startup.SpaceCentre, false)]
    public class DREFlightIntegrator
    {
        public DREFlightIntegrator()
        {
        }


        //private static voidThermalDataDelegate updateConvectionOverride;

        //ModularFlightIntegrator.voidThermalDataDelegate
        


        //solarFlux 
        //solarFluxMultiplier;
        //bodyEmissiveFlux
        // bodyAlbedoFlux;
    
        //densityThermalLerp

        //ModularFlightIntegrator.voidThermalDataDelegate RegisterOverrideConvection = ProcessUpdateConvection;
        //ModularFlightIntegrator.voidThermalDataDelegate RegisterUpdateConvection = ProcessUpdateConvection;  

        public void Awake()
        {
            bool convectionOverridden=false;
            convectionOverridden =  ModularFlightIntegrator.RegisterUpdateConvectionOverride(ProcessUpdateConvection);
            if (!convectionOverridden)
                Debug.Log("[DRE]: Unable to override stock convection heating!");
        }

        public static void ProcessUpdateConvection (ModularFlightIntegrator fi, ModularFlightIntegrator.PartThermalData ptd)
        {

            Part part = ptd.part;
            part.temperature = Double.MaxValue;
            return;
            // get sub/transonic convection
            double convectionArea = UtilMath.Lerp(part.radiativeArea, part.exposedArea,
                                                  (part.machNumber - PhysicsGlobals.FullToCrossSectionLerpStart) / (PhysicsGlobals.FullToCrossSectionLerpEnd - PhysicsGlobals.FullToCrossSectionLerpStart));
            
            double convectiveFlux = (part.externalTemperature - part.temperature) * fi.convectiveCoefficient * convectionArea;
            
            // get hypersonic convection
            // defaults to starting at M=0.8 and being full at M=2.05
            double machLerp = (part.machNumber - PhysicsGlobals.MachConvectionStart) / (PhysicsGlobals.MachConvectionEnd - PhysicsGlobals.MachConvectionStart);
            if (machLerp > 0)
            {
                double machHeatingFlux =
                    part.exposedArea
                        * 1.83e-4d
                        * Math.Pow(part.vessel.speed, PhysicsGlobals.ConvectionVelocityExponent)
                        * Math.Pow(part.atmDensity, PhysicsGlobals.ConvectionDensityExponent)/Math.Max(0.625d,Math.Sqrt(part.exposedArea / Math.PI)); // should be sqrt(density/nose radiu)s
                
                machHeatingFlux *= (double)PhysicsGlobals.ConvectionFactor;
                convectiveFlux = UtilMath.Lerp(convectiveFlux, machHeatingFlux, machLerp);
            }
            convectiveFlux *= 0.001d * part.heatConvectiveConstant * ptd.convectionAreaMultiplier; // W to kW, scalars
            part.thermalConvectionFlux = convectiveFlux;
            part.temperature += convectiveFlux;
            //part.temperature = Math.Max((part.temperature + convectiveFlux * part.thermalMassReciprocal * TimeWarp.fixedDeltaTime), PhysicsGlobals.SpaceTemperature);
        }

        /*
        protected void ProcessRadiationUpdate(UpdateRadiationDelegate UpdateRadiation)
        {
        }

        protected void UpdateRadiation(ModularFlightIntegrator.PartThermalData ptd)
        {
            Part part = ptd.part;
            // shared scalar
            double scalar = part.emissiveConstant // local scalar
                * PhysicsGlobals.RadiationFactor // global scalar
                    * 0.001d; // W to kW
            
            double sunFlux = 0d;
            
            if (ptd.part.vessel.directSunlight)
            {
                // assume half the surface area is under sunlight
                sunFlux = _GetSunArea(ptd) * scalar * solarFlux * solarFluxMultiplier;
            }
            double bodyFlux = 0d;
            double tempBodyFlux = bodyEmissiveFlux + bodyAlbedoFlux;
            if (tempBodyFlux > 0d)
            {
                bodyFlux = UtilMath.Lerp(0.0, tempBodyFlux, densityThermalLerp) * _GetBodyArea(ptd) * scalar;
            }
            
            // Radiative flux = S-Bconst*e*A * (T^4 - radInT^4)
            part.thermalRadiationFlux = sunFlux + bodyFlux;
            
            //part.temperature = Math.Max(tempTemp, PhysicsGlobals.SpaceTemperature);
        }
        
        public double _GetSunArea(ModularFlightIntegrator.PartThermalData ptd)
        {
            Part p = ptd.part;
            if (p.DragCubes.None)
                return 0d;
            Vector3 localSun = p.partTransform.InverseTransformDirection(sunVector);
            return p.DragCubes.GetCubeAreaDir(localSun) * ptd.sunAreaMultiplier;
        }
        
        public double _GetBodyArea(ModularFlightIntegrator.PartThermalData ptd)
        {
            Part p = ptd.part;
            if (p.DragCubes.None)
                return 0d;
            Vector3 bodyLocal = p.partTransform.InverseTransformDirection(-vessel.upAxis);
            return p.DragCubes.GetCubeAreaDir(bodyLocal) * ptd.bodyAreaMultiplier;
        }
        */
    }
}

