//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using KSP;
using UnityEngine;
using ModularFI;

namespace DeadlyReentry
{
    public class DREFlightIntegrator : ModularFlightIntegrator
    {
        public DREFlightIntegrator()
        {
        }

        protected delegate void UpdateConvectionDelegate(PartThermalData ptd);

        protected void ProcessConvectionUpdate(UpdateConvectionDelegate UpdateConvection);

        protected void updateConvection (PartThermalData ptd)
        {
            Part part = ptd.part;
            // get sub/transonic convection
            double convectionArea = UtilMath.Lerp(part.radiativeArea, part.exposedArea,
                                                  (part.machNumber - PhysicsGlobals.FullToCrossSectionLerpStart) / (PhysicsGlobals.FullToCrossSectionLerpEnd - PhysicsGlobals.FullToCrossSectionLerpStart));
            
            double convectiveFlux = (part.externalTemperature - part.temperature) * convectiveCoefficient * convectionArea;
            
            // get hypersonic convection
            // defaults to starting at M=0.8 and being full at M=2.05
            double machLerp = (part.machNumber - PhysicsGlobals.MachConvectionStart) / (PhysicsGlobals.MachConvectionEnd - PhysicsGlobals.MachConvectionStart);
            if (machLerp > 0)
            {
                double machHeatingFlux =
                    part.exposedArea
                        * 1.83e-4d
                        * Math.Pow(vessel.speed, PhysicsGlobals.ConvectionVelocityExponent)
                        * Math.Pow(part.atmDensity, PhysicsGlobals.ConvectionDensityExponent)/Math.Max(0.625d,Math.Sqrt(part.exposedArea / Math.PI)); // should be sqrt(density/nose radiu)s
                
                machHeatingFlux *= (double)PhysicsGlobals.ConvectionFactor;
                convectiveFlux = UtilMath.Lerp(convectiveFlux, machHeatingFlux, machLerp);
            }
            convectiveFlux *= 0.001d * part.heatConvectiveConstant * ptd.convectionAreaMultiplier; // W to kW, scalars
            part.thermalConvectionFlux = convectiveFlux;
            //part.temperature = Math.Max((part.temperature + convectiveFlux * part.thermalMassReciprocal * TimeWarp.fixedDeltaTime), PhysicsGlobals.SpaceTemperature);
        }
        delegate void UpdateRadiationDelegate(PartThermalData ptd);
        
        delegate void ProcessRadiationUpdate(UpdateConvectionDelegate updateRadiation);

        protected override void UpdateRadiation(PartThermalData ptd)
        {
            Part part = ptd.part;
            // shared scalar
            double scalar = part.emissiveConstant // local scalar
                * PhysicsGlobals.RadiationFactor // global scalar
                    * 0.001d; // W to kW
            
            double sunFlux = 0d;
            
            if (vessel.directSunlight)
            {
                // assume half the surface area is under sunlight
                sunFlux = _GetSunArea(ptd) * scalar * solarFlux * solarFluxMultiplier;
            }
            double bodyFlux = 0d;
            double tempBodyFlux = bodyEmissiveFlux + bodyAlbedoFlux;
            if (tempBodyFlux > 0d)
            {
                bodyFlux = UtilMath.Lerp(0.0, tempBodyFlux, this.densityThermalLerp) * _GetBodyArea(ptd) * scalar;
            }
            
            // Radiative flux = S-Bconst*e*A * (T^4 - radInT^4)
            part.thermalRadiationFlux = sunFlux + bodyFlux;
            
            //part.temperature = Math.Max(tempTemp, PhysicsGlobals.SpaceTemperature);
        }
        
        public double _GetSunArea(PartThermalData ptd)
        {
            Part p = ptd.part;
            if (p.DragCubes.None)
                return 0d;
            Vector3 localSun = p.partTransform.InverseTransformDirection(sunVector);
            return p.DragCubes.GetCubeAreaDir(localSun) * ptd.sunAreaMultiplier;
        }
        
        public double _GetBodyArea(PartThermalData ptd)
        {
            Part p = ptd.part;
            if (p.DragCubes.None)
                return 0d;
            Vector3 bodyLocal = p.partTransform.InverseTransformDirection(-vessel.upAxis);
            return p.DragCubes.GetCubeAreaDir(bodyLocal) * ptd.bodyAreaMultiplier;
        }
    }
}

